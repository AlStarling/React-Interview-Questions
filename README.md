## JavaScript:

<details>
<summary>Типы данных</summary>
<br/>
<ul>
<details>
<summary>Примитивные</summary>
<ul>
<li><b>«string»</b>: строки текста, например, "Hello, world!".</li>
<li><b>«number»</b>: числовые значения, как целые, так и дробные, например, 42 или 3.14.</li>
<li><b>«boolean»</b>: логические значения true или false.</li>
<li><b>«null»</b>: специальное значение, которое представляет отсутствие какого-либо значения.</li>
<li><b>«undefined»</b>: значение переменной, которая была объявлена, но не была инициализирована.</li>
<li><b>«symbol»</b>: уникальный и неизменяемый идентификатор, используется для создания уникальных ключей объектов.</li>
<li><b>«bigint»</b>: тип данных для представления целых чисел произвольной длины, например, 9007199254740991n.</li>
</ul>
</details>
<details>
<summary>Объектные</summary>
<ul>
<li><b>«object»</b>: коллекция свойств и методов, которая может включать объекты, массивы, функции и другие структуры данных.</li>
</ul>
</details>
</ul>
<br/>
</details>
<details>
<summary>Цикл событий <b>(Event Loop)</b></summary>
<ul><b>Event Loop</b> управляет выполнением кода, обработкой событий и выполнением асинхронных операций в JavaScript. Он следит за тем, чтобы задачи в очереди были выполнены после завершения текущего стека вызовов. Если в очереди есть задачи (например, асинхронные функции или обработчики событий), Event Loop добавляет их в стек вызовов для выполнения.</ul>
</details>
<details>
<summary>Замыкание</summary>
<ul>Замыкание — это функция, которая запоминает переменные из своего окружения. Она продолжает использовать эти переменные даже после завершения выполнения функции, в которой была создана.</ul>
</details>
<details>
<summary>Прототип объекта</summary>
<ul>В JavaScript объекты могут наследовать свойства и методы от других объектов через прототипы. Если объект не имеет искомого свойства или метода, JavaScript будет искать его в прототипе этого объекта. Это механизм, позволяющий использовать наследование и переиспользование кода.</ul>
</details>
<details>
<summary>Ключевое слово <b>«this»</b></summary>
<ul><b>«this»</b> ссылается на текущий контекст выполнения функции. Контекст может меняться в зависимости от того, как была вызвана функция. Например, в методе объекта this будет ссылаться на объект, а в функции, вызванной в глобальной области, this будет ссылаться на глобальный объект (в браузере — на window).</ul>
</details>
<details>
<summary>Методы <b>«call()»</b>, <b>«apply()»</b> и <b>«bind()»</b></summary>
<ul>Эти методы используются для управления контекстом this в функциях:</ul>
<ul>
<li><b>«call()»</b>: вызывает функцию с указанным контекстом this и передает аргументы по одному.</li>
<li><b>«apply()»</b>: аналогичен call(), но аргументы передаются в виде массива.</li>
<li><b>«bind()»</b>: возвращает новую функцию с фиксированным значением this, которую можно вызвать позже.</li>
</ul>
</details>
<details>
<summary><b>«Promise»</b> (Промис)</summary>
<ul>Промисы позволяют работать с асинхронными операциями в JavaScript, избегая вложенности колбэков. Промис может быть в одном из трёх состояний:</ul>
<ul>
<li><b>«pending»</b> (ожидание) — начальное состояние.</li>
<li><b>«fulfilled»</b> (выполнен) — операция завершена успешно.</li>
<li><b>«rejected»</b> (отклонён) — операция завершена с ошибкой.</li>
</ul>
</details>
<details>
<summary>Статический метод класса <b>(static)</b></summary>
<ul>Методы, помеченные как static, могут быть вызваны непосредственно на классе, а не на его экземплярах. Они обычно используются для создания утилитарных функций, связанных с классом, но не с конкретным экземпляром.</ul>
</details>
<details>
<summary><b>«Set»</b>, <b>«Map»</b>, <b>«WeakSet»</b>, <b>«WeakMap»</b></summary>
<ul>
<li><b>«Set»</b>: структура данных для хранения уникальных значений. Множество не допускает повторяющихся элементов.</li>
<li><b>«Map»</b>: структура данных, позволяющая хранить пары ключ-значение, где ключи могут быть любого типа.</li>
<li><b>«WeakSet»</b>: похож на Set, но хранит только объекты и позволяет сборщику мусора удалять неиспользуемые объекты.</li>
<li><b>«WeakMap»</b>: аналогичен Map, но ключами могут быть только объекты, и ссылки на них не предотвращают сборку мусора.</li>
</ul>
</details>
<details>
<summary>Разница между <b>==</b> и <b>===</b></summary>
<ul>
<p><b>==</b> (нестрогое равенство): Сравнивает значения, преобразуя их к одному типу.</p>
<p><b>===</b> (строгое равенство): Сравнивает значения и типы, не изменяя их.</p>
</ul>
</details>
<details>
<summary>Strict mode</summary>
<ul>Strict mode в JavaScript — это режим, который включает дополнительные проверки и ограничения для кода, чтобы избежать потенциальных ошибок и улучшить безопасность.</ul>
<ul>Когда код работает в строгом режиме:</ul>
<ul>
<li>Объявление переменных без var, let или const приводит к ошибке.</li>
<li>Не допускается использование зарезервированных слов (например, class, enum).</li>
<li>Запрещены некоторые устаревшие и потенциально небезопасные функции (например, with).</li>
<li>Определены более строгие правила для работы с объектами и функциями (например, нельзя удалять свойства объектов или переопределять их).</li>
</ul>
<ul>Strict mode активируется с помощью директивы "use strict"; в начале файла или функции.</ul>
</details>
<details>
<summary><b>«function declaration»</b> и <b>«function expression»</b></summary>
<ul>
<li>Function Declaration: Определяется как обычная функция и доступна для использования в любом месте в своей области видимости, даже до строки, где она была объявлена. Это связано с тем, что её объявление поднимается (hoisted) вверх области видимости.</li>
<li>Function Expression: Создается как часть выражения и доступна только после её строки определения. Она не поднимается вверх, и её можно использовать только после того, как она была присвоена переменной.</li>
</ul>
</details>
<details>
<summary><b>«null»</b> и <b>«undefined»</b></summary>
<ul>
<li><b>«null»</b>: Явное указание на отсутствие значения. Используется для того, чтобы обозначить, что переменная существует, но не имеет значимого значения.</li>
<li><b>«undefined»</b>: Значение, которое автоматически присваивается переменной, если она была объявлена, но не инициализирована, или если функция не возвращает значение.</li>
</ul>
</details>
<details>
<summary>Типы таймеров в JavaScript?</summary>
<ul>
<li><b>«setTimeout»</b>: Выполняет функцию один раз через заданный интервал времени.</li>
<li><b>«setInterval»</b>: Выполняет функцию периодически через заданные интервалы времени.</li>
</ul>
<ul>Оба метода возвращают идентификатор таймера, который можно использовать для его остановки с помощью <b>«clearTimeout»</b> или <b>«clearInterval»</b>.</ul>
</details>
<details>
<summary>Операторы «И» и «ИЛИ» (&& и ||)?</summary>
<ul>
<li><b>«&&»</b> (логическое И): Вернёт true, только если оба условия верны. Иначе — false.</li>
<li><b>«||»</b> (логическое ИЛИ): Вернёт true, если хотя бы одно из условий верно. Если ни одно не верно, вернёт false.</li>
</ul>
</details>
<details>
<summary><b>«var»</b> <b>«let»</b> и <b>«const»</b></summary>
<ul>
<li><b>«var»</b>: Объявляет переменную, которая доступна в функции или глобальной области видимости. Переменные, объявленные с var, можно переопределять и они поднимаются (hoisting), то есть доступны до строки объявления.</li>
<li><b>«let»</b>: Объявляет переменную, доступную только в блоке, где она была объявлена (например, внутри if или for). Переменные с let можно переопределять, и они не поднимаются (hoisting) выше строки объявления.</li>
<li><b>«const»</b>: Объявляет константу, которая доступна только в блоке, где она была объявлена. Значение переменной с const нельзя изменить, но если это объект или массив, то их содержимое можно изменять. Также не поднимается (hoisting).</li>
</ul>
</details>
<details>
<summary>Функции высшего порядка</summary>
<ul>
<p>Функции высшего порядка — это функции, которые могут:</p>
<li>Принимать функции в качестве аргументов: Это позволяет передавать функции как параметры, что даёт возможность изменять поведение функций или использовать их в различных контекстах. Например, функция может принимать другую функцию, чтобы выполнить её в определённых условиях.</li>
<li>Возвращать функции как результат: Это позволяет создавать функции, которые возвращают другие функции, что полезно для создания частично применённых функций, функций с замыканиями и других сложных конструкций.</li>
</ul>
</details>
<details>
<summary>Методы строк</summary>
<ul>
<li>charAt(): Возвращает символ по указанному индексу.</li>
<li>charCodeAt(): Возвращает код символа по указанному индексу.</li>
<li>concat(): Соединяет несколько строк в одну.</li>
<li>includes(): Проверяет, содержит ли строка указанную подстроку.</li>
<li>indexOf(): Возвращает индекс первого вхождения указанной подстроки.</li>
<li>lastIndexOf(): Возвращает индекс последнего вхождения указанной подстроки.</li>
<li>match(): Находит совпадения с регулярным выражением.</li>
<li>replace(): Заменяет часть строки, соответствующую регулярному выражению или строке, другой строкой.</li>
<li>search(): Ищет совпадение с регулярным выражением и возвращает его индекс.</li>
<li>slice(): Извлекает часть строки между двумя индексами.</li>
<li>split(): Разбивает строку на массив подстрок по указанному разделителю.</li>
<li>substring(): Возвращает подстроку между двумя индексами.</li>
<li>toLowerCase(): Преобразует строку в нижний регистр.</li>
<li>toUpperCase(): Преобразует строку в верхний регистр.</li>
<li>trim(): Удаляет пробелы с начала и конца строки.</li>
<li>trimStart() / trimLeft(): Удаляет пробелы с начала строки.</li>
<li>trimEnd() / trimRight(): Удаляет пробелы с конца строки.</li>
<li>padStart(): Дополняет строку до заданной длины с начала.</li>
<li>padEnd(): Дополняет строку до заданной длины с конца.</li>
<li>repeat(): Повторяет строку указанное количество раз.</li>
<li>localeCompare(): Сравнивает строку с другой строкой в соответствии с языковыми настройками.</li>
</ul>
</details>
<details>
<summary>Методы массивов</summary>
<ul>
<li>concat(): Объединяет несколько массивов в один.</li>
<li>copyWithin(): Копирует часть массива на другое место внутри этого же массива.</li>
<li>entries(): Возвращает итератор с парами [индекс, значение] для каждого элемента массива.</li>
<li>every(): Проверяет, удовлетворяют ли все элементы массива условию функции.</li>
<li>fill(): Заполняет элементы массива от начального до конечного индекса заданным значением.</li>
<li>filter(): Создает новый массив с элементами, которые удовлетворяют условию функции.</li>
<li>find(): Возвращает первый элемент массива, который удовлетворяет условию функции.</li>
<li>findIndex(): Возвращает индекс первого элемента, который удовлетворяет условию функции.</li>
<li>flat(): Создает новый массив, объединяя подмассивы до указанного уровня.</li>
<li>flatMap(): Применяет функцию к каждому элементу массива и объединяет результаты в новый массив.</li>
<li>forEach(): Выполняет функцию для каждого элемента массива.</li>
<li>from(): Создает новый массив из объекта или другого массива.</li>
<li>includes(): Проверяет, содержит ли массив указанный элемент.</li>
<li>indexOf(): Возвращает первый индекс, по которому найден указанный элемент, или -1, если элемент не найден.</li>
<li>join(): Объединяет все элементы массива в строку, используя заданный разделитель.</li>
<li>keys(): Возвращает итератор, содержащий ключи (индексы) элементов массива.</li>
<li>lastIndexOf(): Возвращает последний индекс, по которому найден указанный элемент, или -1, если элемент не найден.</li>
<li>map(): Создает новый массив с результатами вызова функции для каждого элемента массива.</li>
<li>pop(): Удаляет последний элемент из массива и возвращает его.</li>
<li>push(): Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.</li>
<li>reduce(): Применяет функцию к аккумулятору и каждому элементу массива (слева направо), чтобы получить одно значение.</li>
<li>reduceRight(): Применяет функцию к аккумулятору и каждому элементу массива (справа налево), чтобы получить одно значение.</li>
<li>reverse(): Изменяет порядок элементов массива на обратный.</li>
<li>shift(): Удаляет первый элемент из массива и возвращает его.</li>
<li>slice(): Создает новый массив, содержащий копию части оригинального массива.</li>
<li>sort(): Сортирует элементы массива на месте и возвращает отсортированный массив.</li>
<li>splice(): Изменяет содержимое массива, удаляя, заменяя или добавляя элементы.</li>
<li>toLocaleString(): Возвращает строку, представляющую элементы массива с учётом языковых настроек.</li>
<li>toString(): Возвращает строку, представляющую элементы массива.</li>
<li>unshift(): Добавляет один или несколько элементов в начало массива и возвращает новую длину массива.</li>
<li>values(): Возвращает итератор, содержащий значения элементов массива.</li>
</ul>
</details>
<details>
<summary>Чистая функция</summary>
<ul>
<p>Чистая функция — это функция, которая:</p>
<li>Возвращает один и тот же результат для одинаковых входных данных: Если вы вызовете её с одними и теми же аргументами, она всегда вернёт тот же результат, независимо от того, сколько раз вы её вызовете.</li>
<li>Не изменяет внешнее состояние: Она не имеет побочных эффектов, таких как изменение глобальных переменных, работа с файлами или взаимодействие с внешними системами. Всё, что делает функция, — это вычисляет результат на основе её входных данных и возвращает его.</li>
<br/>
<p>Такие функции легко тестировать, понимать и использовать, так как они не зависят от состояния вне их области видимости.</p>
</ul>
</details>
<details>
<summary>Разница между .forEach() и .map()</summary>
<ul>
<li>.forEach(): Выполняет указанную функцию для каждого элемента массива, не создавая нового массива. Используется для побочных эффектов, таких как вывод данных на экран.</li>
<li>.map(): Применяет указанную функцию к каждому элементу массива и возвращает новый массив с преобразованными значениями. Используется для преобразования данных.</li>
</ul>
</details>
<details>
<summary>Почему в JS функции называют объектами первого класса?</summary>
<ul>
<li>Функции могут быть присвоены переменным: Вы можете сохранить функцию в переменную.</li>
<li>Функции могут быть переданы как аргументы: Вы можете передать функции другим функциям.</li>
<li>Функции могут быть возвращены из других функций: Вы можете возвращать функции из других функций.</li>
<li>Функции могут быть созданы динамически: Вы можете создавать функции во время выполнения.</li>
<p>Это означает, что функции в JavaScript обладают всеми свойствами и поведением обычных объектов.</p>
</ul>
</details>
<details>
<summary>Что такое IIFE</summary>
<br/>
<p>IIFE (Immediately Invoked Function Expression) — это анонимная функция, которая немедленно выполняется после её объявления. Это позволяет создать локальный контекст и изолировать переменные от глобального пространства.</p>
</details>
<details>
<summary>Что такое псевдомассив arguments?</summary>
<ul>
<p>Псевдомассив arguments — это специальный объект, доступный внутри функции, который содержит все аргументы, переданные этой функции.</p>
<p>Свойства:</p>
<li>arguments индексирован как массив, то есть можно получить доступ к аргументам по индексу (например, arguments[0]).</li>
<li>Имеет свойство length, которое указывает количество переданных аргументов.</li>
<p>Отличие от массива:</p>
<li>arguments не имеет методов массива, таких как map(), filter() или forEach().</li>
<li>Не поддерживает синтаксис массивов, такой как деструктуризация.</li>
</ul>
</details>
<details>
<summary>Почему результат сравнения 2х объектов это false?</summary>
<ul>
<p>В JavaScript, результат сравнения двух объектов будет false, потому что объекты сравниваются по ссылке, а не по значению. Это означает, что даже если два объекта содержат одинаковые данные, они будут считаться разными, если у них разные ссылки в памяти.</p>
<p>Ключевые моменты:</p>
<li>Сравнение по ссылке: Сравниваются адреса памяти объектов.</li>
<li>Одни и те же данные, разные объекты: Даже если два объекта имеют одинаковые свойства и значения, их сравнение будет false, если это разные экземпляры.</li>
</ul>
</details>
<details>
<summary>Прототипное наследование в JavaScript</summary>
<ul>
<p>Прототипное наследование в JavaScript — это механизм, позволяющий объектам наследовать свойства и методы от других объектов. Каждый объект имеет скрытое свойство [[Prototype]], которое указывает на другой объект (прототип), от которого он наследует.</p>
<p>Как создать объект без прототипа:</p>
<p>Можно использовать метод Object.create(null). Этот метод создаёт новый объект без прототипа, то есть объект не имеет свойства [[Prototype]], от которого бы наследовал.</p>
</ul>
</details>
<details>
<summary>Почему расширение нативных JavaScript-объектов это плохая практика?</summary>
<ul>
<p>Расширение нативных JavaScript-объектов считается плохой практикой по следующим причинам:</p>
<li>Конфликты имен: Расширение встроенных объектов может привести к конфликтам с существующими методами или свойствами, добавляемыми в будущих версиях JavaScript.</li>
<li>Непредсказуемость: Модификация нативных объектов может затруднить понимание и поддержку кода, так как неочевидные изменения могут влиять на другие части кода.</li>
<li>Совместимость: Расширения могут нарушить совместимость с другими библиотеками или фреймворками, которые могут ожидать стандартное поведение объектов.</li>
<li>Производительность: Изменения в нативных объектах могут влиять на производительность, особенно если модификации затрагивают часто используемые объекты, такие как Array или Object.</li>
<p>Поэтому рекомендуется использовать композицию или наследование для расширения функциональности, избегая модификации встроенных объектов.</p>
</ul>
</details>
<details>
<summary>Что такое NaN? Как определить, что значение равно NaN?</summary>
<ul>
<p>NaN (Not-a-Number) — это специальное значение в JavaScript, которое представляет собой результат операций, которые не могут быть выполнены с числами, например, деление нуля на ноль или попытка преобразования нечислового значения в число.</p>
<p>Как определить, что значение равно NaN:</p>
<li>Используйте функцию Number.isNaN(), так как оператор == и === не могут надёжно определить NaN (из-за того, что NaN не равен сам себе).</li>
</ul>
</details>
<details>
<summary>Объектная обёртка (Wrapper Object)</summary>
<ul>
<p>Объектная обёртка (Wrapper Object) в JavaScript — это специальный объект, который оборачивает примитивное значение и добавляет методы для работы с этим значением.</p>
<p>Есть три основных типа объектных обёрток:</p>
<li>String: Оборачивает строковое значение и добавляет методы для работы со строками.</li>
<li>Number: Оборачивает числовое значение и добавляет методы для работы с числами.</li>
<li>Boolean: Оборачивает логическое значение и добавляет методы для работы с булевыми значениями.</li>
</ul>
</details>
<details>
<summary>Для чего используется ключевое слово new?</summary>
<ul>
<p>Ключевое слово new в JavaScript используется для создания нового экземпляра объекта с помощью функции-конструктора. Оно выполняет следующие действия:</p>
<li>Создание нового объекта: Создаёт новый пустой объект.</li>
<li>Установка прототипа: Устанавливает прототип нового объекта на prototype функции-конструктора.</li>
<li>Выполнение функции-конструктора: Выполняет функцию-конструктор в контексте нового объекта (this внутри функции указывает на новый объект).</li>
<li>Возврат объекта: Возвращает новый объект, если функция-конструктор не возвращает другой объект.</li>
</ul>
</details>
<details>
<summary>Что такое конструкторы</summary>
<ul>
<p>В JavaScript конструкторы — это специальные функции, которые используются для создания и инициализации объектов. Они предназначены для работы с ключевым словом new, которое позволяет создавать новые экземпляры объектов на основе конструктора.</p>
<p>Основные особенности конструкторов:</p>
<details>
<summary>Функция-конструктор:</summary>
<ul>
<li>Это обычная функция, которая используется с new для создания объектов.</li>
<li>Конструктор устанавливает начальные значения для свойств объекта и может добавлять методы.</li>
</ul>
</details>
<details>
<summary>Использование new:</summary>
<ul><li>Ключевое слово new создаёт новый объект и вызывает конструктор с этим новым объектом как контекстом (this).</li></ul>
</details>
<details>
<summary>Прототип:</summary>
<ul><li>Каждый конструктор имеет свойство prototype, которое позволяет добавлять методы и свойства, доступные для всех объектов, созданных с помощью этого конструктора.</li></ul>
</details>
</ul>
</details>
<details>
<summary>Для чего используется оператор двойного отрицания (!!)?</summary>
<ul>Оператор двойного отрицания (!!) преобразует значение в true или false. Он делает это, сначала инвертируя значение (переводя его в противоположное логическое значение), а затем снова инвертируя его, чтобы получить истинное булевое значение.</ul>
</details>
<details>
<summary>Для чего используется оператор остатка (%)?</summary>
<ul>Оператор остатка (%) в JavaScript используется для нахождения остатка от деления одного числа на другое. Он возвращает оставшуюся часть после деления.</ul>
</details>
<details>
<summary></summary>
</details>
<details>
<summary></summary>
</details>
<details>
<summary></summary>
</details>
<br/>

## React:
<details>
<summary>Методы жизненного цикла компонента</summary>
<p>Классовые компоненты в React имеют методы, которые позволяют выполнять код на разных этапах жизненного цикла компонента:</p>
<ul>
<li><b>«componentDidMount»</b>: вызывается после того, как компонент был вставлен в DOM.</li>
<li><b>«componentDidUpdate»</b>: вызывается после обновления компонента.</li>
<li><b>«componentWillUnmount»</b>: вызывается перед удалением компонента из DOM.</li>
</ul>
</details>
<details>
<summary>Context в React</summary>
<ul>Context предоставляет способ передавать данные (например, тему, язык) через дерево компонентов без необходимости передавать пропсы вручную на каждом уровне.</ul>
</details>
<details>
<summary>Виртуальный <b>DOM</b></summary>
<ul>Виртуальный <b>DOM</b> — это легковесное представление реального DOM. При изменении состояния компонента React сначала обновляет виртуальный DOM, затем вычисляет минимальные изменения и применяет их в реальном DOM, что позволяет избежать лишних обновлений и повышает производительность.</ul>
</details>
<details>
<summary>Атрибут <b>«key»</b></summary>
<ul><b>«key»</b> используется для уникальной идентификации элементов в списке. Это помогает React эффективно обновлять интерфейс, зная, какие элементы были изменены, добавлены или удалены.</ul>
</details>
<details>
<summary>Пропc <b>«children»</b></summary>
<ul><b>«children»</b> — это специальный пропс, который позволяет передавать вложенные элементы внутрь компонента. Используется, когда нужно отобразить произвольное количество дочерних элементов внутри компонента.</ul>
</details>
<details>
<summary>Управляемые и не управляемые компоненты</summary>
<ul>
<li>Управляемые компоненты имеют свое состояние, контролируемое через React state, и изменение состояния компонента приводит к его перерисовке.</li>
<li>Не управляемые компоненты управляют своим состоянием самостоятельно, часто с использованием рефов для доступа к DOM-элементам напрямую.</li>
</ul>
</details>
<details>
<summary>PureComponent</summary>
<ul>PureComponent — это компонент, который автоматически выполняет поверхностное сравнение пропсов и состояния для оптимизации производительности, предотвращая ненужные перерисовки.</ul>
</details>
<details>
<summary>Компонент высшего порядка (HOC)</summary>
<ul>HOC — это функция, которая принимает компонент и возвращает новый компонент с добавленным функционалом. Это шаблон для повторного использования кода в компонентах.</ul>
</details>
<details>
<summary>Хуки в React:</summary>
<br/>
<ul>
<details>
<summary>useState</summary>
<ul>
<li><b>Назначение</b>: Управление состоянием в функциональных компонентах.</li>
<li><b>Принцип работы</b>: Возвращает массив из двух элементов: текущего состояния и функции для его обновления. При вызове функции обновления состояние обновляется, и компонент перерисовывается.</li>
</ul>
</details>
<details>
<summary>useEffect</summary>
<ul>
<li><b>Назначение</b>: Выполнение побочных эффектов, таких как запросы к API, изменение заголовков документа, установка подписок и др.</li>
<li><b>Принцип работы</b>: Принимает функцию эффекта и массив зависимостей. Эффект выполняется после рендера компонента и при изменении зависимостей. Также можно вернуть функцию очистки, которая выполнится перед следующим эффектом или при размонтировании компонента.</li>
</ul>
</details>
<details>
<summary>useContext</summary>
<ul>
<li><b>Назначение</b>: Доступ к значению контекста, созданного с помощью React.createContext.</li>
<li><b>Принцип работы</b>: Позволяет компоненту подписываться на изменения контекста и получать его значение, не передавая его через пропсы.</li>
</ul>
</details>
<details>
<summary>useReducer</summary>
<ul>
<li><b>Назначение</b>: Управление состоянием с использованием редюсера, что полезно для более сложной логики состояния.</li>
<li><b>Принцип работы</b>: Принимает редюсер (функцию для обработки действий) и начальное состояние. Возвращает текущее состояние и функцию dispatch, которая отправляет действия для обновления состояния.</li>
</ul>
</details>
<details>
<summary>useMemo</summary>
<ul>
<li><b>Назначение</b>: Оптимизация производительности путем кэширования вычисленных значений.</li>
<li><b>Принцип работы</b>: Принимает функцию, вычисляющую значение, и массив зависимостей. Возвращает кэшированное значение, если зависимости не изменились, что предотвращает повторные вычисления.</li>
</ul>
</details>
<details>
<summary>useCallback</summary>
<ul>
<li><b>Назначение</b>: Оптимизация производительности путем кэширования функций.</li>
<li><b>Принцип работы</b>: Принимает функцию и массив зависимостей. Возвращает кэшированную функцию, которая пересоздается только при изменении зависимостей. Это помогает избежать ненужных рендеров дочерних компонентов, которые зависят от этой функции.</li>
</ul>
</details>
<details>
<summary>useRef</summary>
<ul>
<li><b>Назначение</b>: Сохранение мутабельных значений и доступ к DOM-элементам.</li>
<li><b>Принцип работы</b>: Возвращает объект с текущим свойством (current). Этот объект сохраняется между рендерами и может использоваться для хранения любых значений или ссылок на DOM-элементы.</li>
</ul>
</details>
<details>
<summary>useImperativeHandle</summary>
<ul>
<li><b>Назначение</b>: Настройка значений, возвращаемых ref, для родительских компонентов.</li>
<li><b>Принцип работы</b>: Используется совместно с forwardRef. Позволяет настраивать и контролировать, что именно будет доступно родительским компонентам через ref.</li>
</ul>
</details>
</ul>
</details>
<details>
<summary>Порталы в React:</summary>
<ul>Порталы позволяют рендерить компоненты в отдельные узлы DOM, вне родительской иерархии компонента, что полезно для создания модальных окон и других элементов, которые должны находиться вне основного DOM-дерева.</ul>
</details>
<details>
<summary>React Reconciliation (Cверка):</summary>
<ul>Процесс сверки заключается в сравнении виртуальной DOM с её предыдущей версией, чтобы определить минимальный набор изменений, которые необходимо внести в реальную DOM для синхронизации с новым состоянием.</ul>
</details>
<details>
<summary>Анимации в React:</summary>
<ul>Анимации можно создавать с помощью CSS-анимаций, а также с помощью библиотек, таких как react-transition-group (для простых переходов) или framer-motion (для более сложных анимаций).</ul>
</details>
<br/>

## Flux-архитектура, Redux и MobX
<details>
<summary>Flux-архитектура:</summary>
<ul>Flux — это шаблон управления потоком данных в приложении, который состоит из Actions (действий), Dispatcher (распределителя), Stores (хранилищ) и Views (представлений). Flux был предложен Facebook и является основой для Redux, который упрощает управление состоянием в больших приложениях.</ul>
</details>
<br/>

## Веб-технологии
<details>
<summary>HTTP</summary>
<ul>Протокол передачи гипертекста (HTTP) используется для обмена данными между клиентом и сервером. Он работает по принципу запрос-ответ, где клиент отправляет запрос, а сервер возвращает ответ.</ul>
</details>
<details>
<summary>Состав HTTP-запроса</summary>
<ul>Каждый HTTP-запрос состоит из метода (например, GET или POST), URL, версии протокола, заголовков (headers), и тела (body) запроса (в случае методов, которые передают данные).</ul>
</details>
<details>
<summary>Методы HTTP-запросов</summary>
<ul>
<li><b>GET</b>: получение данных с сервера.</li>
<li><b>POST</b>: отправка данных на сервер для создания нового ресурса.</li>
<li><b>PUT</b>: обновление существующего ресурса.</li>
<li><b>DELETE</b>: удаление ресурса.</li>
<li><b>PATCH</b>: частичное обновление ресурса.</li>
<li><b>OPTIONS</b>: получение информации о поддерживаемых сервером методах.</li>
</ul>
</details>
<details>
<summary>Cross-Origin Resource Sharing (CORS)</summary>
<ul>CORS — это механизм безопасности, который ограничивает доступ к ресурсам на веб-странице из другого домена, защищая от атак типа "межсайтовый скриптинг" (XSS).</ul>
</details>
<details>
<summary>HTTP cookie</summary>
<ul>Cookies — это небольшие файлы, которые сохраняются в браузере и используются для хранения данных, таких как сеансовые идентификаторы и предпочтения пользователя.</ul>
</details>
<details>
<summary>Принципы ООП</summary>
<p>Основные принципы объектно-ориентированного программирования:</p>
<ul>
<li>Абстракция: выделение общих характеристик и создание простых моделей.</li>
<li>Инкапсуляция: скрытие внутренней реализации и защита данных.</li>
<li>Наследование: создание новых классов на основе существующих.</li>
<li>Полиморфизм: использование одного интерфейса для разных типов данных.</li>
</ul>
</details>
<details>
<summary>SOLID</summary>
<p>SOLID — это акроним из пяти принципов проектирования:</p>
<ul>
<li>S: Single Responsibility Principle (Принцип единственной ответственности).</li>
<li>O: Open/Closed Principle (Принцип открытости/закрытости).</li>
<li>L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).</li>
<li>I: Interface Segregation Principle (Принцип разделения интерфейсов).</li>
<li>D: Dependency Inversion Principle (Принцип инверсии зависимостей).</li>
</ul>
</details>
<details>
<summary>Babel</summary>
<ul>Babel — это транспилятор, который позволяет преобразовывать код, написанный на современном JavaScript, в более старый, совместимый с устаревшими браузерами код.</ul>
</details>
<details>
<summary>WebSocket</summary>
<ul>WebSocket — это протокол, обеспечивающий двустороннюю связь между клиентом и сервером в режиме реального времени. В отличие от HTTP, WebSocket позволяет серверу отправлять данные клиенту без запроса.</ul>
</details>
<details>
<summary>Веб-компоненты</summary>
<p>Веб-компоненты — это набор технологий, включающих:</p>
<ul>
<li>Custom Elements: создание пользовательских HTML-элементов.</li>
<li>Shadow DOM: инкапсуляция стилей и структуры компонента, чтобы избежать конфликтов с основным DOM.</li>
<li>HTML Templates: создание шаблонов, которые можно использовать для генерации HTML-контента.</li>
</ul>
</details>
