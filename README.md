## JavaScript:

<details>
<summary>Типы данных</summary>
<br/>
<ul>
<details>
<summary>Примитивные</summary>
<ul>
<li><b>«string»</b>: строки текста, например, "Hello, world!".</li>
<li><b>«number»</b>: числовые значения, как целые, так и дробные, например, 42 или 3.14.</li>
<li><b>«boolean»</b>: логические значения true или false.</li>
<li><b>«null»</b>: специальное значение, которое представляет отсутствие какого-либо значения.</li>
<li><b>«undefined»</b>: значение переменной, которая была объявлена, но не была инициализирована.</li>
<li><b>«symbol»</b>: уникальный и неизменяемый идентификатор, используется для создания уникальных ключей объектов.</li>
<li><b>«bigint»</b>: тип данных для представления целых чисел произвольной длины, например, 9007199254740991n.</li>
</ul>
</details>
<details>
<summary>Объектные</summary>
<ul>
<li><b>«object»</b>: коллекция свойств и методов, которая может включать объекты, массивы, функции и другие структуры данных.</li>
</ul>
</details>
</ul>
<br/>
</details>
<details>
<summary>Цикл событий <b>(Event Loop)</b></summary>
<ul><b>Event Loop</b> управляет выполнением кода, обработкой событий и выполнением асинхронных операций в JavaScript. Он следит за тем, чтобы задачи в очереди были выполнены после завершения текущего стека вызовов. Если в очереди есть задачи (например, асинхронные функции или обработчики событий), Event Loop добавляет их в стек вызовов для выполнения.</ul>
</details>
<details>
<summary>Замыкание</summary>
<ul>Замыкание возникает, когда функция запоминает переменные из своего лексического окружения, даже если она вызывается за пределами этой области видимости. Это позволяет функции получить доступ к переменным, которые существовали в момент её создания, что делает замыкания мощным инструментом для работы с состоянием и конфигурацией.</ul>
</details>
<details>
<summary>Прототип объекта</summary>
<ul>В JavaScript объекты могут наследовать свойства и методы от других объектов через прототипы. Если объект не имеет искомого свойства или метода, JavaScript будет искать его в прототипе этого объекта. Это механизм, позволяющий использовать наследование и переиспользование кода.</ul>
</details>
<details>
<summary>Ключевое слово <b>«this»</b></summary>
<ul><b>«this»</b> ссылается на текущий контекст выполнения функции. Контекст может меняться в зависимости от того, как была вызвана функция. Например, в методе объекта this будет ссылаться на объект, а в функции, вызванной в глобальной области, this будет ссылаться на глобальный объект (в браузере — на window).</ul>
</details>
<details>
<summary>Методы <b>«call()»</b>, <b>«apply()»</b> и <b>«bind()»</b></summary>
<ul>Эти методы используются для управления контекстом this в функциях:</ul>
<ul>
<li><b>«call()»</b>: вызывает функцию с указанным контекстом this и передает аргументы по одному.</li>
<li><b>«apply()»</b>: аналогичен call(), но аргументы передаются в виде массива.</li>
<li><b>«bind()»</b>: возвращает новую функцию с фиксированным значением this, которую можно вызвать позже.</li>
</ul>
</details>
<details>
<summary><b>«Promise»</b> (Промис)</summary>
<ul>Промисы позволяют работать с асинхронными операциями в JavaScript, избегая вложенности колбэков. Промис может быть в одном из трёх состояний:</ul>
<ul>
<li><b>«pending»</b> (ожидание) — начальное состояние.</li>
<li><b>«fulfilled»</b> (выполнен) — операция завершена успешно.</li>
<li><b>«rejected»</b> (отклонён) — операция завершена с ошибкой.</li>
</ul>
</details>
<details>
<summary>Статический метод класса <b>(static)</b></summary>
<ul>Методы, помеченные как static, могут быть вызваны непосредственно на классе, а не на его экземплярах. Они обычно используются для создания утилитарных функций, связанных с классом, но не с конкретным экземпляром.</ul>
</details>
<details>
<summary><b>«Set»</b>, <b>«Map»</b>, <b>«WeakSet»</b>, <b>«WeakMap»</b></summary>
<ul>
<li><b>«Set»</b>: структура данных для хранения уникальных значений. Множество не допускает повторяющихся элементов.</li>
<li><b>«Map»</b>: структура данных, позволяющая хранить пары ключ-значение, где ключи могут быть любого типа.</li>
<li><b>«WeakSet»</b>: похож на Set, но хранит только объекты и позволяет сборщику мусора удалять неиспользуемые объекты.</li>
<li><b>«WeakMap»</b>: аналогичен Map, но ключами могут быть только объекты, и ссылки на них не предотвращают сборку мусора.</li>
</ul>
</details>
<details>
<summary>Разница между <b>==</b> и <b>===</b></summary>
<ul>
<p><b>==</b> (нестрогое равенство): Сравнивает значения, преобразуя их к одному типу.</p>
<p><b>===</b> (строгое равенство): Сравнивает значения и типы, не изменяя их.</p>
</ul>
</details>
<details>
<summary>Strict mode</summary>
<ul>Strict mode в JavaScript — это режим, который включает дополнительные проверки и ограничения для кода, чтобы избежать потенциальных ошибок и улучшить безопасность.</ul>
<ul>Когда код работает в строгом режиме:</ul>
<ul>
<li>Объявление переменных без var, let или const приводит к ошибке.</li>
<li>Не допускается использование зарезервированных слов (например, class, enum).</li>
<li>Запрещены некоторые устаревшие и потенциально небезопасные функции (например, with).</li>
<li>Определены более строгие правила для работы с объектами и функциями (например, нельзя удалять свойства объектов или переопределять их).</li>
</ul>
<ul>Strict mode активируется с помощью директивы "use strict"; в начале файла или функции.</ul>
</details>
<details>
<summary></summary>
</details>
<details>
<summary></summary>
</details>
<details>
<summary></summary>
</details>
<details>
<summary></summary>
</details>
<br/>

## React:
<details>
<summary>Методы жизненного цикла компонента</summary>
<p>Классовые компоненты в React имеют методы, которые позволяют выполнять код на разных этапах жизненного цикла компонента:</p>
<ul>
<li><b>«componentDidMount»</b>: вызывается после того, как компонент был вставлен в DOM.</li>
<li><b>«componentDidUpdate»</b>: вызывается после обновления компонента.</li>
<li><b>«componentWillUnmount»</b>: вызывается перед удалением компонента из DOM.</li>
</ul>
</details>
<details>
<summary>Context в React</summary>
<ul>Context предоставляет способ передавать данные (например, тему, язык) через дерево компонентов без необходимости передавать пропсы вручную на каждом уровне.</ul>
</details>
<details>
<summary>Виртуальный <b>DOM</b></summary>
<ul>Виртуальный <b>DOM</b> — это легковесное представление реального DOM. При изменении состояния компонента React сначала обновляет виртуальный DOM, затем вычисляет минимальные изменения и применяет их в реальном DOM, что позволяет избежать лишних обновлений и повышает производительность.</ul>
</details>
<details>
<summary>Атрибут <b>«key»</b></summary>
<ul><b>«key»</b> используется для уникальной идентификации элементов в списке. Это помогает React эффективно обновлять интерфейс, зная, какие элементы были изменены, добавлены или удалены.</ul>
</details>
<details>
<summary>Пропc <b>«children»</b></summary>
<ul><b>«children»</b> — это специальный пропс, который позволяет передавать вложенные элементы внутрь компонента. Используется, когда нужно отобразить произвольное количество дочерних элементов внутри компонента.</ul>
</details>
<details>
<summary>Управляемые и не управляемые компоненты</summary>
<ul>
<li>Управляемые компоненты имеют свое состояние, контролируемое через React state, и изменение состояния компонента приводит к его перерисовке.</li>
<li>Не управляемые компоненты управляют своим состоянием самостоятельно, часто с использованием рефов для доступа к DOM-элементам напрямую.</li>
</ul>
</details>
<details>
<summary>PureComponent</summary>
<ul>PureComponent — это компонент, который автоматически выполняет поверхностное сравнение пропсов и состояния для оптимизации производительности, предотвращая ненужные перерисовки.</ul>
</details>
<details>
<summary>Компонент высшего порядка (HOC)</summary>
<ul>HOC — это функция, которая принимает компонент и возвращает новый компонент с добавленным функционалом. Это шаблон для повторного использования кода в компонентах.</ul>
</details>
<details>
<summary>Хуки в React:</summary>
<br/>
<ul>
<details>
<summary>useState</summary>
<ul>
<li><b>Назначение</b>: Управление состоянием в функциональных компонентах.</li>
<li><b>Принцип работы</b>: Возвращает массив из двух элементов: текущего состояния и функции для его обновления. При вызове функции обновления состояние обновляется, и компонент перерисовывается.</li>
</ul>
</details>
<details>
<summary>useEffect</summary>
<ul>
<li><b>Назначение</b>: Выполнение побочных эффектов, таких как запросы к API, изменение заголовков документа, установка подписок и др.</li>
<li><b>Принцип работы</b>: Принимает функцию эффекта и массив зависимостей. Эффект выполняется после рендера компонента и при изменении зависимостей. Также можно вернуть функцию очистки, которая выполнится перед следующим эффектом или при размонтировании компонента.</li>
</ul>
</details>
<details>
<summary>useContext</summary>
<ul>
<li><b>Назначение</b>: Доступ к значению контекста, созданного с помощью React.createContext.</li>
<li><b>Принцип работы</b>: Позволяет компоненту подписываться на изменения контекста и получать его значение, не передавая его через пропсы.</li>
</ul>
</details>
<details>
<summary>useReducer</summary>
<ul>
<li><b>Назначение</b>: Управление состоянием с использованием редюсера, что полезно для более сложной логики состояния.</li>
<li><b>Принцип работы</b>: Принимает редюсер (функцию для обработки действий) и начальное состояние. Возвращает текущее состояние и функцию dispatch, которая отправляет действия для обновления состояния.</li>
</ul>
</details>
<details>
<summary>useMemo</summary>
<ul>
<li><b>Назначение</b>: Оптимизация производительности путем кэширования вычисленных значений.</li>
<li><b>Принцип работы</b>: Принимает функцию, вычисляющую значение, и массив зависимостей. Возвращает кэшированное значение, если зависимости не изменились, что предотвращает повторные вычисления.</li>
</ul>
</details>
<details>
<summary>useCallback</summary>
<ul>
<li><b>Назначение</b>: Оптимизация производительности путем кэширования функций.</li>
<li><b>Принцип работы</b>: Принимает функцию и массив зависимостей. Возвращает кэшированную функцию, которая пересоздается только при изменении зависимостей. Это помогает избежать ненужных рендеров дочерних компонентов, которые зависят от этой функции.</li>
</ul>
</details>
<details>
<summary>useRef</summary>
<ul>
<li><b>Назначение</b>: Сохранение мутабельных значений и доступ к DOM-элементам.</li>
<li><b>Принцип работы</b>: Возвращает объект с текущим свойством (current). Этот объект сохраняется между рендерами и может использоваться для хранения любых значений или ссылок на DOM-элементы.</li>
</ul>
</details>
<details>
<summary>useImperativeHandle</summary>
<ul>
<li><b>Назначение</b>: Настройка значений, возвращаемых ref, для родительских компонентов.</li>
<li><b>Принцип работы</b>: Используется совместно с forwardRef. Позволяет настраивать и контролировать, что именно будет доступно родительским компонентам через ref.</li>
</ul>
</details>
</ul>
</details>
<details>
<summary>Порталы в React:</summary>
<ul>Порталы позволяют рендерить компоненты в отдельные узлы DOM, вне родительской иерархии компонента, что полезно для создания модальных окон и других элементов, которые должны находиться вне основного DOM-дерева.</ul>
</details>
<details>
<summary>React Reconciliation (Cверка):</summary>
<ul>Процесс сверки заключается в сравнении виртуальной DOM с её предыдущей версией, чтобы определить минимальный набор изменений, которые необходимо внести в реальную DOM для синхронизации с новым состоянием.</ul>
</details>
<details>
<summary>Анимации в React:</summary>
<ul>Анимации можно создавать с помощью CSS-анимаций, а также с помощью библиотек, таких как react-transition-group (для простых переходов) или framer-motion (для более сложных анимаций).</ul>
</details>
<br/>

## Flux-архитектура, Redux и MobX
<details>
<summary>Flux-архитектура:</summary>
<ul>Flux — это шаблон управления потоком данных в приложении, который состоит из Actions (действий), Dispatcher (распределителя), Stores (хранилищ) и Views (представлений). Flux был предложен Facebook и является основой для Redux, который упрощает управление состоянием в больших приложениях.</ul>
</details>
<br/>

## Веб-технологии
<details>
<summary>HTTP</summary>
<ul>Протокол передачи гипертекста (HTTP) используется для обмена данными между клиентом и сервером. Он работает по принципу запрос-ответ, где клиент отправляет запрос, а сервер возвращает ответ.</ul>
</details>
<details>
<summary>Состав HTTP-запроса</summary>
<ul>Каждый HTTP-запрос состоит из метода (например, GET или POST), URL, версии протокола, заголовков (headers), и тела (body) запроса (в случае методов, которые передают данные).</ul>
</details>
<details>
<summary>Методы HTTP-запросов</summary>
<ul>
<li><b>GET</b>: получение данных с сервера.</li>
<li><b>POST</b>: отправка данных на сервер для создания нового ресурса.</li>
<li><b>PUT</b>: обновление существующего ресурса.</li>
<li><b>DELETE</b>: удаление ресурса.</li>
<li><b>PATCH</b>: частичное обновление ресурса.</li>
<li><b>OPTIONS</b>: получение информации о поддерживаемых сервером методах.</li>
</ul>
</details>
<details>
<summary>Cross-Origin Resource Sharing (CORS)</summary>
<ul>CORS — это механизм безопасности, который ограничивает доступ к ресурсам на веб-странице из другого домена, защищая от атак типа "межсайтовый скриптинг" (XSS).</ul>
</details>
<details>
<summary>HTTP cookie</summary>
<ul>Cookies — это небольшие файлы, которые сохраняются в браузере и используются для хранения данных, таких как сеансовые идентификаторы и предпочтения пользователя.</ul>
</details>
<details>
<summary>Принципы ООП</summary>
<p>Основные принципы объектно-ориентированного программирования:</p>
<ul>
<li>Абстракция: выделение общих характеристик и создание простых моделей.</li>
<li>Инкапсуляция: скрытие внутренней реализации и защита данных.</li>
<li>Наследование: создание новых классов на основе существующих.</li>
<li>Полиморфизм: использование одного интерфейса для разных типов данных.</li>
</ul>
</details>
<details>
<summary>SOLID</summary>
<p>SOLID — это акроним из пяти принципов проектирования:</p>
<ul>
<li>S: Single Responsibility Principle (Принцип единственной ответственности).</li>
<li>O: Open/Closed Principle (Принцип открытости/закрытости).</li>
<li>L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).</li>
<li>I: Interface Segregation Principle (Принцип разделения интерфейсов).</li>
<li>D: Dependency Inversion Principle (Принцип инверсии зависимостей).</li>
</ul>
</details>
<details>
<summary>Babel</summary>
<ul>Babel — это транспилятор, который позволяет преобразовывать код, написанный на современном JavaScript, в более старый, совместимый с устаревшими браузерами код.</ul>
</details>
<details>
<summary>WebSocket</summary>
<ul>WebSocket — это протокол, обеспечивающий двустороннюю связь между клиентом и сервером в режиме реального времени. В отличие от HTTP, WebSocket позволяет серверу отправлять данные клиенту без запроса.</ul>
</details>
<details>
<summary>Веб-компоненты</summary>
<p>Веб-компоненты — это набор технологий, включающих:</p>
<ul>
<li>Custom Elements: создание пользовательских HTML-элементов.</li>
<li>Shadow DOM: инкапсуляция стилей и структуры компонента, чтобы избежать конфликтов с основным DOM.</li>
<li>HTML Templates: создание шаблонов, которые можно использовать для генерации HTML-контента.</li>
</ul>
</details>
